/**\n * Integration Tests for Instructions Flow\n * Tests the complete instructions generation and retrieval flow\n */\n\nimport request from 'supertest';\nimport express from 'express';\nimport { instructionGenerator } from '../../services/instruction-generator.service';\nimport instructionsRoutes from '../../routes/instructions.routes';\nimport { DeletionInstruction } from '../../types/bot';\n\n// Setup Express app for testing\nconst app = express();\napp.use(express.json());\napp.use('/api/instructions', instructionsRoutes);\n\n// Mock instruction data\nconst mockInstructions: Record<string, DeletionInstruction> = {\n  'dyxless': {\n    botId: 'dyxless',\n    encryptedName: 'Бот A',\n    steps: [\n      {\n        stepNumber: 1,\n        description: 'Для того чтобы удалить данные вам нужно активировать бота \"Бот A\"',\n        action: 'activate_bot'\n      },\n      {\n        stepNumber: 2,\n        description: 'Выбрать раздел \"мой профиль\" - \"удалить информацию обо мне\"',\n        action: 'navigate_to_profile'\n      }\n    ],\n    estimatedTime: '5-10 минут',\n    difficulty: 'easy',\n    requirements: ['Telegram аккаунт', 'Доступ к интернету']\n  },\n  'itp': {\n    botId: 'itp',\n    encryptedName: 'Бот B',\n    steps: [\n      {\n        stepNumber: 1,\n        description: 'Для того чтобы удалить данные вам нужно активировать бота \"Бот B\"',\n        action: 'activate_bot'\n      },\n      {\n        stepNumber: 2,\n        description: 'Выбрать раздел \"мой профиль\" - \"удалить информацию обо мне\"',\n        action: 'navigate_to_profile'\n      }\n    ],\n    estimatedTime: '3-7 минут',\n    difficulty: 'easy',\n    requirements: ['Telegram аккаунт']\n  },\n  'leak_osint': {\n    botId: 'leak_osint',\n    encryptedName: 'Бот C',\n    steps: [\n      {\n        stepNumber: 1,\n        description: 'Для того чтобы удалить данные вам нужно активировать бота \"Бот C\"',\n        action: 'activate_bot'\n      },\n      {\n        stepNumber: 2,\n        description: 'Выбрать раздел \"мой профиль\" - \"удалить информацию обо мне\"',\n        action: 'navigate_to_profile'\n      }\n    ],\n    estimatedTime: '5-15 минут',\n    difficulty: 'medium',\n    requirements: ['Telegram аккаунт', 'Подтверждение личности']\n  }\n};\n\ndescribe('Instructions Integration Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('Instructions Retrieval', () => {\n    it('should retrieve instructions for valid bot ID', async () => {\n      jest.spyOn(instructionGenerator, 'getInstructions')\n        .mockResolvedValue(mockInstructions.dyxless);\n\n      const response = await request(app)\n        .get('/api/instructions/dyxless')\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data).toHaveProperty('botId', 'dyxless');\n      expect(response.body.data).toHaveProperty('encryptedName', 'Бот A');\n      expect(response.body.data).toHaveProperty('steps');\n      expect(response.body.data.steps).toHaveLength(2);\n      expect(response.body.data).toHaveProperty('estimatedTime');\n      expect(response.body.data).toHaveProperty('difficulty');\n      expect(response.body.data).toHaveProperty('requirements');\n    });\n\n    it('should return 404 for invalid bot ID', async () => {\n      jest.spyOn(instructionGenerator, 'getInstructions')\n        .mockResolvedValue(null);\n\n      const response = await request(app)\n        .get('/api/instructions/invalid_bot')\n        .expect(404);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('NOT_FOUND_ERROR');\n      expect(response.body.error.message).toContain('not found');\n    });\n\n    it('should handle service errors gracefully', async () => {\n      jest.spyOn(instructionGenerator, 'getInstructions')\n        .mockRejectedValue(new Error('Service temporarily unavailable'));\n\n      const response = await request(app)\n        .get('/api/instructions/dyxless')\n        .expect(500);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('INSTRUCTIONS_ERROR');\n    });\n  });\n\n  describe('Instructions Content Validation', () => {\n    it('should return properly formatted instructions with all required fields', async () => {\n      jest.spyOn(instructionGenerator, 'getInstructions')\n        .mockResolvedValue(mockInstructions.leak_osint);\n\n      const response = await request(app)\n        .get('/api/instructions/leak_osint')\n        .expect(200);\n\n      const instructions = response.body.data;\n      \n      // Validate structure\n      expect(instructions).toHaveProperty('botId');\n      expect(instructions).toHaveProperty('encryptedName');\n      expect(instructions).toHaveProperty('steps');\n      expect(instructions).toHaveProperty('estimatedTime');\n      expect(instructions).toHaveProperty('difficulty');\n      expect(instructions).toHaveProperty('requirements');\n      \n      // Validate steps structure\n      instructions.steps.forEach((step: any, index: number) => {\n        expect(step).toHaveProperty('stepNumber', index + 1);\n        expect(step).toHaveProperty('description');\n        expect(step).toHaveProperty('action');\n        expect(typeof step.description).toBe('string');\n        expect(step.description.length).toBeGreaterThan(0);\n      });\n      \n      // Validate encrypted name format\n      expect(instructions.encryptedName).toMatch(/^Бот [A-Z]$/);\n      \n      // Validate requirements array\n      expect(Array.isArray(instructions.requirements)).toBe(true);\n      expect(instructions.requirements.length).toBeGreaterThan(0);\n    });\n\n    it('should return instructions with encrypted bot names', async () => {\n      const testCases = [\n        { botId: 'dyxless', expectedName: 'Бот A' },\n        { botId: 'itp', expectedName: 'Бот B' },\n        { botId: 'leak_osint', expectedName: 'Бот C' }\n      ];\n\n      for (const testCase of testCases) {\n        jest.spyOn(instructionGenerator, 'getInstructions')\n          .mockResolvedValue(mockInstructions[testCase.botId]);\n\n        const response = await request(app)\n          .get(`/api/instructions/${testCase.botId}`)\n          .expect(200);\n\n        expect(response.body.data.encryptedName).toBe(testCase.expectedName);\n        \n        // Ensure the real bot name is not exposed\n        const responseText = JSON.stringify(response.body);\n        expect(responseText).not.toContain('dyxless');\n        expect(responseText).not.toContain('InfoTrackPeople');\n        expect(responseText).not.toContain('LeakOsint');\n      }\n    });\n  });\n\n  describe('Instructions Generation Integration', () => {\n    it('should generate instructions for all supported bots', async () => {\n      const supportedBots = ['dyxless', 'itp', 'leak_osint', 'userbox', 'vektor'];\n      \n      for (const botId of supportedBots) {\n        const mockInstruction = {\n          botId,\n          encryptedName: `Бот ${String.fromCharCode(65 + supportedBots.indexOf(botId))}`, // A, B, C, etc.\n          steps: [\n            {\n              stepNumber: 1,\n              description: `Активировать бота \"${botId}\"`,\n              action: 'activate_bot'\n            }\n          ],\n          estimatedTime: '5-10 минут',\n          difficulty: 'easy',\n          requirements: ['Telegram аккаунт']\n        };\n\n        jest.spyOn(instructionGenerator, 'getInstructions')\n          .mockResolvedValue(mockInstruction);\n\n        const response = await request(app)\n          .get(`/api/instructions/${botId}`)\n          .expect(200);\n\n        expect(response.body.success).toBe(true);\n        expect(response.body.data.botId).toBe(botId);\n        expect(response.body.data.steps).toHaveLength(1);\n      }\n    });\n\n    it('should handle dynamic instruction generation based on bot capabilities', async () => {\n      // Mock different instruction complexities for different bots\n      const complexInstruction = {\n        botId: 'complex_bot',\n        encryptedName: 'Бот X',\n        steps: [\n          {\n            stepNumber: 1,\n            description: 'Активировать бота',\n            action: 'activate_bot'\n          },\n          {\n            stepNumber: 2,\n            description: 'Пройти верификацию',\n            action: 'verify_identity'\n          },\n          {\n            stepNumber: 3,\n            description: 'Найти раздел настроек',\n            action: 'navigate_settings'\n          },\n          {\n            stepNumber: 4,\n            description: 'Выбрать удаление данных',\n            action: 'delete_data'\n          }\n        ],\n        estimatedTime: '15-30 минут',\n        difficulty: 'hard',\n        requirements: ['Telegram аккаунт', 'Документы для верификации', 'Номер телефона']\n      };\n\n      jest.spyOn(instructionGenerator, 'getInstructions')\n        .mockResolvedValue(complexInstruction);\n\n      const response = await request(app)\n        .get('/api/instructions/complex_bot')\n        .expect(200);\n\n      expect(response.body.data.steps).toHaveLength(4);\n      expect(response.body.data.difficulty).toBe('hard');\n      expect(response.body.data.requirements).toHaveLength(3);\n      expect(response.body.data.estimatedTime).toContain('15-30');\n    });\n  });\n\n  describe('Instructions Caching Integration', () => {\n    it('should cache instructions for repeated requests', async () => {\n      const getInstructionsSpy = jest.spyOn(instructionGenerator, 'getInstructions')\n        .mockResolvedValue(mockInstructions.dyxless);\n\n      // First request\n      await request(app)\n        .get('/api/instructions/dyxless')\n        .expect(200);\n\n      // Second request\n      await request(app)\n        .get('/api/instructions/dyxless')\n        .expect(200);\n\n      // Third request\n      await request(app)\n        .get('/api/instructions/dyxless')\n        .expect(200);\n\n      // Should be called multiple times since we're not implementing caching in this test\n      // In a real implementation, you might want to test that caching reduces calls\n      expect(getInstructionsSpy).toHaveBeenCalledTimes(3);\n    });\n  });\n\n  describe('Instructions Security Integration', () => {\n    it('should not expose internal bot identifiers', async () => {\n      jest.spyOn(instructionGenerator, 'getInstructions')\n        .mockResolvedValue(mockInstructions.dyxless);\n\n      const response = await request(app)\n        .get('/api/instructions/dyxless')\n        .expect(200);\n\n      const responseText = JSON.stringify(response.body);\n      \n      // Should not contain real bot names or internal identifiers\n      expect(responseText).not.toContain('dyxless');\n      expect(responseText).not.toContain('api-dyxless.cfd');\n      expect(responseText).not.toContain('InfoTrackPeople');\n      expect(responseText).not.toContain('datatech.work');\n      \n      // Should contain encrypted names\n      expect(responseText).toContain('Бот A');\n    });\n\n    it('should sanitize instruction content', async () => {\n      const instructionWithSensitiveData = {\n        ...mockInstructions.dyxless,\n        steps: [\n          {\n            stepNumber: 1,\n            description: 'Активировать бота по ссылке https://t.me/sensitive_bot_name',\n            action: 'activate_bot'\n          }\n        ]\n      };\n\n      jest.spyOn(instructionGenerator, 'getInstructions')\n        .mockResolvedValue(instructionWithSensitiveData);\n\n      const response = await request(app)\n        .get('/api/instructions/dyxless')\n        .expect(200);\n\n      // In a real implementation, you might want to sanitize URLs or sensitive content\n      expect(response.body.data.steps[0].description).toBeDefined();\n    });\n  });\n\n  describe('Instructions Error Handling Integration', () => {\n    it('should handle malformed bot IDs', async () => {\n      const malformedBotIds = [\n        '../../../etc/passwd',\n        '<script>alert(\"xss\")</script>',\n        'bot; DROP TABLE instructions;',\n        'bot%20with%20encoding',\n        ''\n      ];\n\n      for (const botId of malformedBotIds) {\n        jest.spyOn(instructionGenerator, 'getInstructions')\n          .mockResolvedValue(null);\n\n        const response = await request(app)\n          .get(`/api/instructions/${encodeURIComponent(botId)}`)\n          .expect(404);\n\n        expect(response.body.success).toBe(false);\n      }\n    });\n\n    it('should handle instruction generation failures', async () => {\n      const errorScenarios = [\n        { error: new Error('Template not found'), expectedStatus: 500 },\n        { error: new Error('Configuration missing'), expectedStatus: 500 },\n        { error: new Error('Network timeout'), expectedStatus: 500 }\n      ];\n\n      for (const scenario of errorScenarios) {\n        jest.spyOn(instructionGenerator, 'getInstructions')\n          .mockRejectedValue(scenario.error);\n\n        const response = await request(app)\n          .get('/api/instructions/dyxless')\n          .expect(scenario.expectedStatus);\n\n        expect(response.body.success).toBe(false);\n        expect(response.body.error.type).toBe('INSTRUCTIONS_ERROR');\n      }\n    });\n  });\n\n  describe('Instructions Performance Integration', () => {\n    it('should return instructions within reasonable time', async () => {\n      jest.spyOn(instructionGenerator, 'getInstructions')\n        .mockImplementation(async () => {\n          // Simulate some processing time\n          await new Promise(resolve => setTimeout(resolve, 50));\n          return mockInstructions.dyxless;\n        });\n\n      const startTime = Date.now();\n      \n      const response = await request(app)\n        .get('/api/instructions/dyxless')\n        .expect(200);\n\n      const endTime = Date.now();\n      const executionTime = endTime - startTime;\n\n      expect(response.body.success).toBe(true);\n      expect(executionTime).toBeLessThan(1000); // Should complete within 1 second\n    });\n\n    it('should handle concurrent instruction requests', async () => {\n      jest.spyOn(instructionGenerator, 'getInstructions')\n        .mockResolvedValue(mockInstructions.dyxless);\n\n      // Send multiple concurrent requests\n      const promises = Array(10).fill(null).map(() => \n        request(app)\n          .get('/api/instructions/dyxless')\n      );\n\n      const responses = await Promise.all(promises);\n\n      // All requests should succeed\n      responses.forEach(response => {\n        expect(response.status).toBe(200);\n        expect(response.body.success).toBe(true);\n        expect(response.body.data.botId).toBe('dyxless');\n      });\n    });\n  });\n\n  describe('Instructions Localization Integration', () => {\n    it('should return instructions in Russian language', async () => {\n      jest.spyOn(instructionGenerator, 'getInstructions')\n        .mockResolvedValue(mockInstructions.dyxless);\n\n      const response = await request(app)\n        .get('/api/instructions/dyxless')\n        .expect(200);\n\n      const instructions = response.body.data;\n      \n      // Check that text is in Russian\n      expect(instructions.encryptedName).toMatch(/^Бот [А-Я]$/);\n      expect(instructions.steps[0].description).toContain('удалить данные');\n      expect(instructions.steps[1].description).toContain('мой профиль');\n      expect(instructions.estimatedTime).toContain('минут');\n    });\n\n    it('should handle different difficulty levels in Russian', async () => {\n      const difficulties = ['easy', 'medium', 'hard'];\n      const russianDifficulties = ['легко', 'средне', 'сложно'];\n      \n      for (let i = 0; i < difficulties.length; i++) {\n        const mockInstruction = {\n          ...mockInstructions.dyxless,\n          difficulty: difficulties[i]\n        };\n\n        jest.spyOn(instructionGenerator, 'getInstructions')\n          .mockResolvedValue(mockInstruction);\n\n        const response = await request(app)\n          .get('/api/instructions/dyxless')\n          .expect(200);\n\n        expect(response.body.data.difficulty).toBe(difficulties[i]);\n      }\n    });\n  });\n});\n\n// Cleanup after tests\nafterAll(() => {\n  jest.restoreAllMocks();\n});"