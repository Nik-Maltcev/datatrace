/**\n * Integration Tests for Error Handling\n * Tests the complete error handling flow across the application\n */\n\nimport request from 'supertest';\nimport express from 'express';\nimport { apiManager } from '../../services/api-manager.service';\nimport { searchService } from '../../services/search.service';\nimport { errorRecoveryService } from '../../services/error-recovery.service';\nimport searchRoutes from '../../routes/search.routes';\nimport instructionsRoutes from '../../routes/instructions.routes';\nimport { errorMiddleware } from '../../middleware/error.middleware';\nimport { SearchRequest } from '../../types/search';\n\n// Setup Express app for testing\nconst app = express();\napp.use(express.json());\napp.use('/api/search', searchRoutes);\napp.use('/api/instructions', instructionsRoutes);\napp.use(errorMiddleware);\n\n// Test data\nconst testData = {\n  validPhone: '+79123456789',\n  validEmail: 'test@example.com',\n  invalidPhone: '123',\n  invalidEmail: 'invalid-email'\n};\n\ndescribe('Error Handling Integration Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('API Error Handling', () => {\n    it('should handle single API failure gracefully', async () => {\n      // Mock one API to fail while others succeed\n      jest.spyOn(apiManager, 'searchAll').mockResolvedValue(new Map([\n        ['dyxless', { success: true, data: { found: false, results: [] } }],\n        ['itp', { success: false, error: 'Connection timeout' }],\n        ['leakOsint', { success: true, data: { status: 'not_found', data: [] } }],\n        ['userbox', { success: true, data: { found: false, results: [] } }],\n        ['vektor', { success: true, data: { results: [], found: false } }]\n      ]));\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: testData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.summary.totalBotsWithErrors).toBe(1);\n      expect(response.body.data.summary.totalBotsSearched).toBe(5);\n      \n      // Check that the error is properly reported\n      const itpResult = response.body.data.results.find((r: any) => r.botId === 'itp');\n      expect(itpResult.error).toBe('Connection timeout');\n      expect(itpResult.hasData).toBe(false);\n    });\n\n    it('should handle multiple API failures', async () => {\n      // Mock multiple APIs to fail\n      jest.spyOn(apiManager, 'searchAll').mockResolvedValue(new Map([\n        ['dyxless', { success: false, error: 'Rate limit exceeded' }],\n        ['itp', { success: false, error: 'Invalid API key' }],\n        ['leakOsint', { success: true, data: { status: 'found', data: [{ email: 'test@example.com' }] } }],\n        ['userbox', { success: false, error: 'Service unavailable' }],\n        ['vektor', { success: true, data: { results: [], found: false } }]\n      ]));\n\n      const searchRequest: SearchRequest = {\n        type: 'email',\n        value: testData.validEmail\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.summary.totalBotsWithErrors).toBe(3);\n      expect(response.body.data.summary.totalBotsWithData).toBe(1); // LeakOsint found data\n      \n      // Check that successful results are still returned\n      const leakOsintResult = response.body.data.results.find((r: any) => r.botId === 'leak_osint');\n      expect(leakOsintResult.hasData).toBe(true);\n      expect(leakOsintResult.foundData).toHaveLength(1);\n    });\n\n    it('should handle complete API failure', async () => {\n      // Mock all APIs to fail\n      jest.spyOn(apiManager, 'searchAll').mockResolvedValue(new Map([\n        ['dyxless', { success: false, error: 'Network error' }],\n        ['itp', { success: false, error: 'Timeout' }],\n        ['leakOsint', { success: false, error: 'Server error' }],\n        ['userbox', { success: false, error: 'Authentication failed' }],\n        ['vektor', { success: false, error: 'Service down' }]\n      ]));\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: testData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200); // Should still return 200 with error information\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.summary.totalBotsWithErrors).toBe(5);\n      expect(response.body.data.summary.totalBotsWithData).toBe(0);\n      \n      // All results should have errors\n      response.body.data.results.forEach((result: any) => {\n        expect(result.hasData).toBe(false);\n        expect(result.error).toBeDefined();\n        expect(typeof result.error).toBe('string');\n      });\n    });\n  });\n\n  describe('Validation Error Handling', () => {\n    it('should handle invalid phone number format', async () => {\n      const searchRequest = {\n        type: 'phone',\n        value: testData.invalidPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('VALIDATION_ERROR');\n      expect(response.body.error.message).toContain('phone');\n      expect(response.body.error.code).toBe(400);\n      expect(response.body.meta.timestamp).toBeDefined();\n    });\n\n    it('should handle invalid email format', async () => {\n      const searchRequest = {\n        type: 'email',\n        value: testData.invalidEmail\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('VALIDATION_ERROR');\n      expect(response.body.error.message).toContain('email');\n    });\n\n    it('should handle missing required fields', async () => {\n      const invalidRequests = [\n        {}, // Empty request\n        { type: 'phone' }, // Missing value\n        { value: testData.validPhone }, // Missing type\n        { type: 'invalid_type', value: testData.validPhone } // Invalid type\n      ];\n\n      for (const invalidRequest of invalidRequests) {\n        const response = await request(app)\n          .post('/api/search')\n          .send(invalidRequest)\n          .expect(400);\n\n        expect(response.body.success).toBe(false);\n        expect(response.body.error.type).toBe('VALIDATION_ERROR');\n      }\n    });\n\n    it('should handle malformed JSON requests', async () => {\n      const response = await request(app)\n        .post('/api/search')\n        .set('Content-Type', 'application/json')\n        .send('{ invalid json }')\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('VALIDATION_ERROR');\n    });\n  });\n\n  describe('Service Error Handling', () => {\n    it('should handle search service internal errors', async () => {\n      jest.spyOn(searchService, 'searchAllBots')\n        .mockRejectedValue(new Error('Internal service error'));\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: testData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(500);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('SEARCH_ERROR');\n      expect(response.body.error.message).toContain('search');\n    });\n\n    it('should handle API manager errors', async () => {\n      jest.spyOn(apiManager, 'searchAll')\n        .mockRejectedValue(new Error('API manager initialization failed'));\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: testData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(500);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('SEARCH_ERROR');\n    });\n\n    it('should handle instruction service errors', async () => {\n      const response = await request(app)\n        .get('/api/instructions/nonexistent_bot')\n        .expect(404);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('NOT_FOUND_ERROR');\n      expect(response.body.error.message).toContain('not found');\n    });\n  });\n\n  describe('Rate Limiting Error Handling', () => {\n    it('should handle rate limit exceeded errors', async () => {\n      // Mock rate limiting error\n      jest.spyOn(apiManager, 'searchAll').mockResolvedValue(new Map([\n        ['dyxless', { success: false, error: 'Rate limit exceeded. Try again in 60 seconds.' }],\n        ['itp', { success: false, error: 'Too many requests' }],\n        ['leakOsint', { success: true, data: { status: 'not_found', data: [] } }],\n        ['userbox', { success: true, data: { found: false, results: [] } }],\n        ['vektor', { success: true, data: { results: [], found: false } }]\n      ]));\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: testData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.summary.totalBotsWithErrors).toBe(2);\n      \n      // Check that rate limit errors are properly categorized\n      const dyxlessResult = response.body.data.results.find((r: any) => r.botId === 'dyxless');\n      expect(dyxlessResult.error).toContain('Rate limit');\n      \n      const itpResult = response.body.data.results.find((r: any) => r.botId === 'itp');\n      expect(itpResult.error).toContain('Too many requests');\n    });\n  });\n\n  describe('Timeout Error Handling', () => {\n    it('should handle API timeout errors', async () => {\n      jest.spyOn(apiManager, 'searchAll').mockResolvedValue(new Map([\n        ['dyxless', { success: false, error: 'Request timeout after 30 seconds' }],\n        ['itp', { success: true, data: { found: false, results: [] } }],\n        ['leakOsint', { success: false, error: 'Connection timeout' }],\n        ['userbox', { success: true, data: { found: false, results: [] } }],\n        ['vektor', { success: false, error: 'Read timeout' }]\n      ]));\n\n      const searchRequest: SearchRequest = {\n        type: 'email',\n        value: testData.validEmail\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.summary.totalBotsWithErrors).toBe(3);\n      \n      // Check that timeout errors are properly handled\n      const timeoutResults = response.body.data.results.filter((r: any) => \n        r.error && r.error.toLowerCase().includes('timeout')\n      );\n      expect(timeoutResults).toHaveLength(3);\n    });\n\n    it('should handle request timeout at application level', async () => {\n      // Mock a very slow response\n      jest.spyOn(searchService, 'searchAllBots').mockImplementation(async () => {\n        await new Promise(resolve => setTimeout(resolve, 35000)); // 35 seconds\n        return {\n          searchId: 'test-id',\n          results: [],\n          summary: { totalBotsSearched: 0, totalBotsWithData: 0, totalBotsWithErrors: 0 }\n        };\n      });\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: testData.validPhone\n      };\n\n      // This test would timeout in a real scenario\n      // For testing purposes, we'll mock the timeout behavior\n      jest.setTimeout(1000); // Set short timeout for test\n      \n      try {\n        await request(app)\n          .post('/api/search')\n          .send(searchRequest)\n          .timeout(500); // 500ms timeout\n        \n        fail('Should have timed out');\n      } catch (error: any) {\n        expect(error.code).toBe('ECONNABORTED');\n      }\n    });\n  });\n\n  describe('Authentication Error Handling', () => {\n    it('should handle invalid API tokens', async () => {\n      jest.spyOn(apiManager, 'searchAll').mockResolvedValue(new Map([\n        ['dyxless', { success: false, error: 'Invalid token provided' }],\n        ['itp', { success: false, error: 'Authentication failed: Invalid API key' }],\n        ['leakOsint', { success: true, data: { status: 'not_found', data: [] } }],\n        ['userbox', { success: false, error: 'JWT token expired' }],\n        ['vektor', { success: true, data: { results: [], found: false } }]\n      ]));\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: testData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.summary.totalBotsWithErrors).toBe(3);\n      \n      // Check that authentication errors are properly categorized\n      const authErrors = response.body.data.results.filter((r: any) => \n        r.error && (\n          r.error.includes('token') || \n          r.error.includes('Authentication') || \n          r.error.includes('JWT')\n        )\n      );\n      expect(authErrors).toHaveLength(3);\n    });\n  });\n\n  describe('Data Sanitization in Error Handling', () => {\n    it('should not expose sensitive data in error messages', async () => {\n      // Mock an error that might contain sensitive data\n      jest.spyOn(apiManager, 'searchAll')\n        .mockRejectedValue(new Error(`Database query failed for phone: ${testData.validPhone}`));\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: testData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(500);\n\n      expect(response.body.success).toBe(false);\n      \n      // Error message should not contain the actual phone number\n      expect(response.body.error.message).not.toContain(testData.validPhone);\n      expect(response.body.error.message).not.toContain('79123456789');\n    });\n\n    it('should sanitize stack traces in development mode', async () => {\n      const originalEnv = process.env.NODE_ENV;\n      process.env.NODE_ENV = 'development';\n\n      jest.spyOn(searchService, 'searchAllBots')\n        .mockRejectedValue(new Error('Test error with stack trace'));\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: testData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(500);\n\n      expect(response.body.success).toBe(false);\n      \n      // In development, stack trace might be included but should be sanitized\n      if (response.body.error.stack) {\n        expect(response.body.error.stack).not.toContain(testData.validPhone);\n      }\n\n      process.env.NODE_ENV = originalEnv;\n    });\n  });\n\n  describe('Error Recovery Integration', () => {\n    it('should attempt error recovery for transient failures', async () => {\n      let callCount = 0;\n      \n      jest.spyOn(apiManager, 'searchAll').mockImplementation(async () => {\n        callCount++;\n        \n        if (callCount === 1) {\n          // First call fails\n          return new Map([\n            ['dyxless', { success: false, error: 'Temporary network error' }],\n            ['itp', { success: true, data: { found: false, results: [] } }]\n          ]);\n        } else {\n          // Subsequent calls succeed (simulating recovery)\n          return new Map([\n            ['dyxless', { success: true, data: { found: false, results: [] } }],\n            ['itp', { success: true, data: { found: false, results: [] } }]\n          ]);\n        }\n      });\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: testData.validPhone\n      };\n\n      // First request - should show error\n      const response1 = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      expect(response1.body.data.summary.totalBotsWithErrors).toBe(1);\n\n      // Second request - should show recovery\n      const response2 = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      expect(response2.body.data.summary.totalBotsWithErrors).toBe(0);\n    });\n\n    it('should handle circuit breaker activation', async () => {\n      // Mock circuit breaker behavior\n      jest.spyOn(errorRecoveryService, 'shouldSkipApi')\n        .mockReturnValue(true); // Circuit breaker is open\n\n      jest.spyOn(apiManager, 'searchAll').mockResolvedValue(new Map([\n        ['dyxless', { success: false, error: 'Circuit breaker open - API temporarily disabled' }],\n        ['itp', { success: true, data: { found: false, results: [] } }],\n        ['leakOsint', { success: true, data: { status: 'not_found', data: [] } }],\n        ['userbox', { success: true, data: { found: false, results: [] } }],\n        ['vektor', { success: true, data: { results: [], found: false } }]\n      ]));\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: testData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.summary.totalBotsWithErrors).toBe(1);\n      \n      const dyxlessResult = response.body.data.results.find((r: any) => r.botId === 'dyxless');\n      expect(dyxlessResult.error).toContain('Circuit breaker');\n    });\n  });\n\n  describe('Concurrent Error Handling', () => {\n    it('should handle errors in concurrent requests', async () => {\n      let requestCount = 0;\n      \n      jest.spyOn(apiManager, 'searchAll').mockImplementation(async () => {\n        requestCount++;\n        \n        if (requestCount % 2 === 0) {\n          // Even requests fail\n          throw new Error('Simulated concurrent error');\n        } else {\n          // Odd requests succeed\n          return new Map([\n            ['dyxless', { success: true, data: { found: false, results: [] } }]\n          ]);\n        }\n      });\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: testData.validPhone\n      };\n\n      // Send multiple concurrent requests\n      const promises = Array(6).fill(null).map(() => \n        request(app)\n          .post('/api/search')\n          .send(searchRequest)\n      );\n\n      const responses = await Promise.all(promises);\n\n      // Check that some succeeded and some failed\n      const successCount = responses.filter(r => r.status === 200 && r.body.success).length;\n      const errorCount = responses.filter(r => r.status === 500).length;\n      \n      expect(successCount).toBeGreaterThan(0);\n      expect(errorCount).toBeGreaterThan(0);\n      expect(successCount + errorCount).toBe(6);\n    });\n  });\n\n  describe('Error Logging Integration', () => {\n    it('should log errors without sensitive data', async () => {\n      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();\n      \n      jest.spyOn(searchService, 'searchAllBots')\n        .mockRejectedValue(new Error(`Search failed for ${testData.validPhone}`));\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: testData.validPhone\n      };\n\n      await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(500);\n\n      // Check that logs don't contain sensitive data\n      const loggedContent = consoleSpy.mock.calls.flat().join(' ');\n      expect(loggedContent).not.toContain(testData.validPhone);\n      expect(loggedContent).not.toContain('79123456789');\n      \n      consoleSpy.mockRestore();\n    });\n  });\n});\n\n// Cleanup after tests\nafterAll(() => {\n  jest.restoreAllMocks();\n});"