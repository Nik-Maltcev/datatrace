/**\n * Integration Tests for Search Flow\n * Tests the complete search flow from API endpoint to bot clients\n */\n\nimport request from 'supertest';\nimport express from 'express';\nimport { searchService } from '../../services/search.service';\nimport { apiManager } from '../../services/api-manager.service';\nimport { validationService } from '../../services/validation.service';\nimport searchRoutes from '../../routes/search.routes';\nimport { SearchRequest, SearchResult } from '../../types/search';\n\n// Mock data for testing\nconst mockSearchData = {\n  validPhone: '+79123456789',\n  validEmail: 'test@example.com',\n  validINN: '123456789012',\n  validSNILS: '12345678901',\n  validPassport: '1234 567890',\n  invalidPhone: '123',\n  invalidEmail: 'invalid-email',\n  invalidINN: '123'\n};\n\n// Mock API responses\nconst mockApiResponses = {\n  dyxless: {\n    success: true,\n    data: {\n      found: true,\n      results: [{\n        field: 'phone',\n        value: '+79123456789',\n        source: 'telegram'\n      }]\n    }\n  },\n  itp: {\n    success: true,\n    data: {\n      found: false,\n      results: []\n    }\n  },\n  leakOsint: {\n    success: true,\n    data: {\n      status: 'found',\n      data: [{\n        email: 'test@example.com',\n        source: 'leak_db'\n      }]\n    }\n  },\n  userbox: {\n    success: false,\n    error: 'API temporarily unavailable'\n  },\n  vektor: {\n    success: true,\n    data: {\n      results: [],\n      found: false\n    }\n  }\n};\n\n// Setup Express app for testing\nconst app = express();\napp.use(express.json());\napp.use('/api/search', searchRoutes);\n\ndescribe('Search Integration Tests', () => {\n  beforeEach(() => {\n    // Reset mocks before each test\n    jest.clearAllMocks();\n  });\n\n  describe('Complete Search Flow', () => {\n    it('should handle successful search with mixed results', async () => {\n      // Mock API manager to return mixed results\n      jest.spyOn(apiManager, 'searchAll').mockResolvedValue(new Map([\n        ['dyxless', mockApiResponses.dyxless],\n        ['itp', mockApiResponses.itp],\n        ['leakOsint', mockApiResponses.leakOsint],\n        ['userbox', mockApiResponses.userbox], // This one fails\n        ['vektor', mockApiResponses.vektor]\n      ]));\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: mockSearchData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data).toHaveProperty('results');\n      expect(response.body.data).toHaveProperty('searchId');\n      expect(response.body.data).toHaveProperty('summary');\n      \n      const results = response.body.data.results;\n      expect(results).toHaveLength(5); // All 5 bots should be in results\n      \n      // Check that successful results have data\n      const dyxlessResult = results.find((r: any) => r.botId === 'dyxless');\n      expect(dyxlessResult.hasData).toBe(true);\n      expect(dyxlessResult.foundData).toHaveLength(1);\n      \n      // Check that failed API is handled gracefully\n      const userboxResult = results.find((r: any) => r.botId === 'userbox');\n      expect(userboxResult.hasData).toBe(false);\n      expect(userboxResult.error).toBeDefined();\n      \n      // Check summary\n      expect(response.body.data.summary.totalBotsSearched).toBe(5);\n      expect(response.body.data.summary.totalBotsWithData).toBeGreaterThan(0);\n      expect(response.body.data.summary.totalBotsWithErrors).toBe(1);\n    });\n\n    it('should handle search with no data found', async () => {\n      // Mock all APIs to return no data\n      const noDataResponses = new Map([\n        ['dyxless', { success: true, data: { found: false, results: [] } }],\n        ['itp', { success: true, data: { found: false, results: [] } }],\n        ['leakOsint', { success: true, data: { status: 'not_found', data: [] } }],\n        ['userbox', { success: true, data: { found: false, results: [] } }],\n        ['vektor', { success: true, data: { results: [], found: false } }]\n      ]);\n\n      jest.spyOn(apiManager, 'searchAll').mockResolvedValue(noDataResponses);\n\n      const searchRequest: SearchRequest = {\n        type: 'email',\n        value: 'notfound@example.com'\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.summary.totalBotsWithData).toBe(0);\n      expect(response.body.data.results.every((r: any) => !r.hasData)).toBe(true);\n    });\n\n    it('should handle all APIs failing gracefully', async () => {\n      // Mock all APIs to fail\n      const failedResponses = new Map([\n        ['dyxless', { success: false, error: 'Connection timeout' }],\n        ['itp', { success: false, error: 'Invalid API key' }],\n        ['leakOsint', { success: false, error: 'Rate limit exceeded' }],\n        ['userbox', { success: false, error: 'Service unavailable' }],\n        ['vektor', { success: false, error: 'Network error' }]\n      ]);\n\n      jest.spyOn(apiManager, 'searchAll').mockResolvedValue(failedResponses);\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: mockSearchData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200); // Should still return 200 with error info\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.summary.totalBotsWithErrors).toBe(5);\n      expect(response.body.data.summary.totalBotsWithData).toBe(0);\n      expect(response.body.data.results.every((r: any) => r.error)).toBe(true);\n    });\n  });\n\n  describe('Input Validation Integration', () => {\n    it('should reject invalid phone number', async () => {\n      const searchRequest = {\n        type: 'phone',\n        value: mockSearchData.invalidPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('VALIDATION_ERROR');\n      expect(response.body.error.message).toContain('phone');\n    });\n\n    it('should reject invalid email', async () => {\n      const searchRequest = {\n        type: 'email',\n        value: mockSearchData.invalidEmail\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('VALIDATION_ERROR');\n    });\n\n    it('should reject missing search type', async () => {\n      const searchRequest = {\n        value: mockSearchData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('VALIDATION_ERROR');\n    });\n\n    it('should reject empty search value', async () => {\n      const searchRequest = {\n        type: 'phone',\n        value: ''\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error.type).toBe('VALIDATION_ERROR');\n    });\n  });\n\n  describe('Parallel API Requests', () => {\n    it('should execute all API requests in parallel', async () => {\n      const startTime = Date.now();\n      \n      // Mock APIs with delays to test parallelism\n      jest.spyOn(apiManager, 'searchAll').mockImplementation(async () => {\n        // Simulate parallel execution - all should complete around the same time\n        await new Promise(resolve => setTimeout(resolve, 100));\n        return new Map([\n          ['dyxless', mockApiResponses.dyxless],\n          ['itp', mockApiResponses.itp],\n          ['leakOsint', mockApiResponses.leakOsint],\n          ['userbox', { success: true, data: { found: false, results: [] } }],\n          ['vektor', mockApiResponses.vektor]\n        ]);\n      });\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: mockSearchData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      const endTime = Date.now();\n      const executionTime = endTime - startTime;\n\n      expect(response.body.success).toBe(true);\n      // Should complete in roughly 100ms, not 500ms (5 * 100ms) if sequential\n      expect(executionTime).toBeLessThan(300); // Allow some buffer for test execution\n    });\n\n    it('should handle timeout in parallel requests', async () => {\n      // Mock one API to timeout while others succeed\n      jest.spyOn(apiManager, 'searchAll').mockImplementation(async () => {\n        return new Map([\n          ['dyxless', mockApiResponses.dyxless],\n          ['itp', mockApiResponses.itp],\n          ['leakOsint', { success: false, error: 'Request timeout' }],\n          ['userbox', { success: true, data: { found: false, results: [] } }],\n          ['vektor', mockApiResponses.vektor]\n        ]);\n      });\n\n      const searchRequest: SearchRequest = {\n        type: 'email',\n        value: mockSearchData.validEmail\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.summary.totalBotsWithErrors).toBe(1);\n      expect(response.body.data.summary.totalBotsSearched).toBe(5);\n      \n      // Check that the timeout error is properly handled\n      const leakOsintResult = response.body.data.results.find((r: any) => r.botId === 'leak_osint');\n      expect(leakOsintResult.error).toContain('timeout');\n    });\n  });\n\n  describe('Data Types Integration', () => {\n    const testCases = [\n      { type: 'phone', value: mockSearchData.validPhone },\n      { type: 'email', value: mockSearchData.validEmail },\n      { type: 'inn', value: mockSearchData.validINN },\n      { type: 'snils', value: mockSearchData.validSNILS },\n      { type: 'passport', value: mockSearchData.validPassport }\n    ];\n\n    testCases.forEach(({ type, value }) => {\n      it(`should handle ${type} search type`, async () => {\n        jest.spyOn(apiManager, 'searchAll').mockResolvedValue(new Map([\n          ['dyxless', { success: true, data: { found: true, results: [{ field: type, value }] } }],\n          ['itp', mockApiResponses.itp],\n          ['leakOsint', { success: true, data: { status: 'not_found', data: [] } }],\n          ['userbox', { success: true, data: { found: false, results: [] } }],\n          ['vektor', mockApiResponses.vektor]\n        ]));\n\n        const searchRequest: SearchRequest = {\n          type: type as any,\n          value\n        };\n\n        const response = await request(app)\n          .post('/api/search')\n          .send(searchRequest)\n          .expect(200);\n\n        expect(response.body.success).toBe(true);\n        expect(response.body.data.results).toHaveLength(5);\n        \n        const dyxlessResult = response.body.data.results.find((r: any) => r.botId === 'dyxless');\n        expect(dyxlessResult.hasData).toBe(true);\n        expect(dyxlessResult.foundData[0].field).toBe(type);\n      });\n    });\n  });\n\n  describe('Error Recovery Integration', () => {\n    it('should recover from temporary API failures', async () => {\n      let callCount = 0;\n      \n      jest.spyOn(apiManager, 'searchAll').mockImplementation(async () => {\n        callCount++;\n        \n        if (callCount === 1) {\n          // First call - simulate temporary failure\n          return new Map([\n            ['dyxless', { success: false, error: 'Temporary network error' }],\n            ['itp', mockApiResponses.itp],\n            ['leakOsint', mockApiResponses.leakOsint],\n            ['userbox', { success: false, error: 'Service temporarily unavailable' }],\n            ['vektor', mockApiResponses.vektor]\n          ]);\n        } else {\n          // Subsequent calls - simulate recovery\n          return new Map([\n            ['dyxless', mockApiResponses.dyxless],\n            ['itp', mockApiResponses.itp],\n            ['leakOsint', mockApiResponses.leakOsint],\n            ['userbox', { success: true, data: { found: false, results: [] } }],\n            ['vektor', mockApiResponses.vektor]\n          ]);\n        }\n      });\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: mockSearchData.validPhone\n      };\n\n      // First request - should handle failures gracefully\n      const response1 = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      expect(response1.body.data.summary.totalBotsWithErrors).toBe(2);\n\n      // Second request - should show recovery\n      const response2 = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      expect(response2.body.data.summary.totalBotsWithErrors).toBe(0);\n    });\n  });\n\n  describe('Security Integration', () => {\n    it('should not log sensitive data in search requests', async () => {\n      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();\n      const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();\n      \n      jest.spyOn(apiManager, 'searchAll').mockResolvedValue(new Map([\n        ['dyxless', mockApiResponses.dyxless]\n      ]));\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: mockSearchData.validPhone\n      };\n\n      await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      // Check that sensitive data is not in logs\n      const allLogCalls = [...consoleSpy.mock.calls, ...consoleErrorSpy.mock.calls];\n      const loggedContent = allLogCalls.flat().join(' ');\n      \n      expect(loggedContent).not.toContain(mockSearchData.validPhone);\n      expect(loggedContent).not.toContain('79123456789');\n      \n      consoleSpy.mockRestore();\n      consoleErrorSpy.mockRestore();\n    });\n\n    it('should sanitize error messages', async () => {\n      jest.spyOn(apiManager, 'searchAll').mockRejectedValue(\n        new Error(`Database error: Invalid phone ${mockSearchData.validPhone}`)\n      );\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: mockSearchData.validPhone\n      };\n\n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(500);\n\n      expect(response.body.error.message).not.toContain(mockSearchData.validPhone);\n      expect(response.body.error.message).not.toContain('79123456789');\n    });\n  });\n\n  describe('Performance Integration', () => {\n    it('should handle concurrent requests efficiently', async () => {\n      jest.spyOn(apiManager, 'searchAll').mockResolvedValue(new Map([\n        ['dyxless', mockApiResponses.dyxless],\n        ['itp', mockApiResponses.itp]\n      ]));\n\n      const searchRequest: SearchRequest = {\n        type: 'phone',\n        value: mockSearchData.validPhone\n      };\n\n      // Send multiple concurrent requests\n      const promises = Array(5).fill(null).map(() => \n        request(app)\n          .post('/api/search')\n          .send(searchRequest)\n      );\n\n      const responses = await Promise.all(promises);\n\n      // All requests should succeed\n      responses.forEach(response => {\n        expect(response.status).toBe(200);\n        expect(response.body.success).toBe(true);\n      });\n    });\n\n    it('should complete search within reasonable time', async () => {\n      jest.spyOn(apiManager, 'searchAll').mockResolvedValue(new Map([\n        ['dyxless', mockApiResponses.dyxless],\n        ['itp', mockApiResponses.itp],\n        ['leakOsint', mockApiResponses.leakOsint],\n        ['userbox', { success: true, data: { found: false, results: [] } }],\n        ['vektor', mockApiResponses.vektor]\n      ]));\n\n      const searchRequest: SearchRequest = {\n        type: 'email',\n        value: mockSearchData.validEmail\n      };\n\n      const startTime = Date.now();\n      \n      const response = await request(app)\n        .post('/api/search')\n        .send(searchRequest)\n        .expect(200);\n\n      const endTime = Date.now();\n      const executionTime = endTime - startTime;\n\n      expect(response.body.success).toBe(true);\n      expect(executionTime).toBeLessThan(5000); // Should complete within 5 seconds\n    });\n  });\n});\n\n// Cleanup after tests\nafterAll(() => {\n  jest.restoreAllMocks();\n});"