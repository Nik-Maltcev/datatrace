/**\n * Integration Tests for API Clients\n * Tests the integration between API clients and external services\n */\n\nimport { DyxlessClient } from '../../clients/dyxless.client';\nimport { ITPClient } from '../../clients/itp.client';\nimport { LeakOsintClient } from '../../clients/leak-osint.client';\nimport { UserboxClient } from '../../clients/userbox.client';\nimport { VektorClient } from '../../clients/vektor.client';\nimport { ApiResponse } from '../../types/api';\nimport axios from 'axios';\n\n// Mock axios for controlled testing\njest.mock('axios');\nconst mockedAxios = axios as jest.Mocked<typeof axios>;\n\n// Mock environment variables\nprocess.env.DYXLESS_TOKEN = 'test-dyxless-token';\nprocess.env.ITP_TOKEN = 'test-itp-token';\nprocess.env.LEAK_OSINT_TOKEN = 'test-leak-osint-token';\nprocess.env.USERBOX_TOKEN = 'test-userbox-token';\nprocess.env.VEKTOR_TOKEN = 'test-vektor-token';\n\n// Test data\nconst testData = {\n  phone: '+79123456789',\n  email: 'test@example.com',\n  inn: '123456789012',\n  snils: '12345678901',\n  passport: '1234 567890'\n};\n\n// Mock API responses\nconst mockResponses = {\n  dyxless: {\n    success: true,\n    data: {\n      found: true,\n      results: [{\n        field: 'phone',\n        value: '+79123456789',\n        source: 'telegram'\n      }]\n    }\n  },\n  itp: {\n    success: true,\n    data: {\n      found: true,\n      results: [{\n        type: 'phone',\n        value: '+79123456789',\n        sources: ['telegram_bot']\n      }]\n    }\n  },\n  leakOsint: {\n    success: true,\n    data: {\n      status: 'found',\n      data: [{\n        email: 'test@example.com',\n        source: 'leak_db',\n        date: '2023-01-01'\n      }]\n    }\n  },\n  userbox: {\n    success: true,\n    data: {\n      found: false,\n      results: []\n    }\n  },\n  vektor: {\n    success: true,\n    data: {\n      results: [{\n        field: 'inn',\n        value: '123456789012',\n        confidence: 0.95\n      }],\n      found: true\n    }\n  }\n};\n\ndescribe('API Clients Integration Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockedAxios.create.mockReturnValue(mockedAxios);\n  });\n\n  describe('DyxlessClient Integration', () => {\n    let client: DyxlessClient;\n\n    beforeEach(() => {\n      client = new DyxlessClient();\n    });\n\n    it('should successfully search with valid phone number', async () => {\n      mockedAxios.post.mockResolvedValue({\n        data: mockResponses.dyxless.data,\n        status: 200\n      });\n\n      const result = await client.search(testData.phone, 'phone');\n\n      expect(mockedAxios.post).toHaveBeenCalledWith(\n        '/query',\n        {\n          token: 'test-dyxless-token',\n          query: testData.phone\n        },\n        expect.objectContaining({\n          timeout: expect.any(Number),\n          headers: expect.objectContaining({\n            'Content-Type': 'application/json'\n          })\n        })\n      );\n\n      expect(result.success).toBe(true);\n      expect(result.data).toEqual(mockResponses.dyxless.data);\n    });\n\n    it('should handle API timeout', async () => {\n      mockedAxios.post.mockRejectedValue({\n        code: 'ECONNABORTED',\n        message: 'timeout of 30000ms exceeded'\n      });\n\n      const result = await client.search(testData.phone, 'phone');\n\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('timeout');\n    });\n\n    it('should handle API rate limiting', async () => {\n      mockedAxios.post.mockRejectedValue({\n        response: {\n          status: 429,\n          data: { error: 'Rate limit exceeded' }\n        }\n      });\n\n      const result = await client.search(testData.phone, 'phone');\n\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('Rate limit');\n    });\n\n    it('should handle invalid token', async () => {\n      mockedAxios.post.mockRejectedValue({\n        response: {\n          status: 401,\n          data: { error: 'Invalid token' }\n        }\n      });\n\n      const result = await client.search(testData.phone, 'phone');\n\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('Invalid token');\n    });\n  });\n\n  describe('ITPClient Integration', () => {\n    let client: ITPClient;\n\n    beforeEach(() => {\n      client = new ITPClient();\n    });\n\n    it('should successfully search with proper headers', async () => {\n      mockedAxios.post.mockResolvedValue({\n        data: mockResponses.itp.data,\n        status: 200\n      });\n\n      const result = await client.search(testData.phone, 'phone');\n\n      expect(mockedAxios.post).toHaveBeenCalledWith(\n        '/public-api/data/search',\n        {\n          query: testData.phone,\n          type: 'phone'\n        },\n        expect.objectContaining({\n          headers: expect.objectContaining({\n            'x-api-key': 'test-itp-token',\n            'Content-Type': 'application/json'\n          })\n        })\n      );\n\n      expect(result.success).toBe(true);\n      expect(result.data).toEqual(mockResponses.itp.data);\n    });\n\n    it('should handle different search types', async () => {\n      const searchTypes = ['phone', 'email', 'inn', 'snils', 'passport'];\n      const testValues = [testData.phone, testData.email, testData.inn, testData.snils, testData.passport];\n\n      for (let i = 0; i < searchTypes.length; i++) {\n        mockedAxios.post.mockResolvedValue({\n          data: { found: false, results: [] },\n          status: 200\n        });\n\n        const result = await client.search(testValues[i], searchTypes[i] as any);\n\n        expect(mockedAxios.post).toHaveBeenCalledWith(\n          '/public-api/data/search',\n          {\n            query: testValues[i],\n            type: searchTypes[i]\n          },\n          expect.any(Object)\n        );\n\n        expect(result.success).toBe(true);\n      }\n    });\n\n    it('should handle server errors', async () => {\n      mockedAxios.post.mockRejectedValue({\n        response: {\n          status: 500,\n          data: { error: 'Internal server error' }\n        }\n      });\n\n      const result = await client.search(testData.phone, 'phone');\n\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('server error');\n    });\n  });\n\n  describe('LeakOsintClient Integration', () => {\n    let client: LeakOsintClient;\n\n    beforeEach(() => {\n      client = new LeakOsintClient();\n    });\n\n    it('should successfully search with JSON payload', async () => {\n      mockedAxios.post.mockResolvedValue({\n        data: mockResponses.leakOsint.data,\n        status: 200\n      });\n\n      const result = await client.search(testData.email, 'email');\n\n      expect(mockedAxios.post).toHaveBeenCalledWith(\n        '/',\n        {\n          token: 'test-leak-osint-token',\n          request: testData.email,\n          limit: 100,\n          lang: 'ru'\n        },\n        expect.objectContaining({\n          headers: expect.objectContaining({\n            'Content-Type': 'application/json'\n          })\n        })\n      );\n\n      expect(result.success).toBe(true);\n      expect(result.data).toEqual(mockResponses.leakOsint.data);\n    });\n\n    it('should handle different response formats', async () => {\n      const alternativeResponse = {\n        status: 'not_found',\n        message: 'No data found',\n        data: []\n      };\n\n      mockedAxios.post.mockResolvedValue({\n        data: alternativeResponse,\n        status: 200\n      });\n\n      const result = await client.search(testData.email, 'email');\n\n      expect(result.success).toBe(true);\n      expect(result.data).toEqual(alternativeResponse);\n    });\n\n    it('should handle malformed JSON responses', async () => {\n      mockedAxios.post.mockResolvedValue({\n        data: 'Invalid JSON response',\n        status: 200\n      });\n\n      const result = await client.search(testData.email, 'email');\n\n      expect(result.success).toBe(true);\n      expect(result.data).toBe('Invalid JSON response');\n    });\n  });\n\n  describe('UserboxClient Integration', () => {\n    let client: UserboxClient;\n\n    beforeEach(() => {\n      client = new UserboxClient();\n    });\n\n    it('should successfully search with JWT authorization', async () => {\n      mockedAxios.get.mockResolvedValue({\n        data: mockResponses.userbox.data,\n        status: 200\n      });\n\n      const result = await client.search(testData.phone, 'phone');\n\n      expect(mockedAxios.get).toHaveBeenCalledWith(\n        '/search',\n        expect.objectContaining({\n          params: {\n            query: testData.phone,\n            type: 'phone'\n          },\n          headers: expect.objectContaining({\n            'Authorization': 'Bearer test-userbox-token'\n          })\n        })\n      );\n\n      expect(result.success).toBe(true);\n      expect(result.data).toEqual(mockResponses.userbox.data);\n    });\n\n    it('should handle JWT token expiration', async () => {\n      mockedAxios.get.mockRejectedValue({\n        response: {\n          status: 401,\n          data: { error: 'Token expired' }\n        }\n      });\n\n      const result = await client.search(testData.phone, 'phone');\n\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('Token expired');\n    });\n\n    it('should handle URL encoding for special characters', async () => {\n      const specialQuery = 'test+email@domain.com';\n      \n      mockedAxios.get.mockResolvedValue({\n        data: { found: false, results: [] },\n        status: 200\n      });\n\n      await client.search(specialQuery, 'email');\n\n      expect(mockedAxios.get).toHaveBeenCalledWith(\n        '/search',\n        expect.objectContaining({\n          params: {\n            query: specialQuery,\n            type: 'email'\n          }\n        })\n      );\n    });\n  });\n\n  describe('VektorClient Integration', () => {\n    let client: VektorClient;\n\n    beforeEach(() => {\n      client = new VektorClient();\n    });\n\n    it('should successfully search with token in URL', async () => {\n      mockedAxios.get.mockResolvedValue({\n        data: mockResponses.vektor.data,\n        status: 200\n      });\n\n      const result = await client.search(testData.inn, 'inn');\n\n      expect(mockedAxios.get).toHaveBeenCalledWith(\n        `/api/test-vektor-token/extended_search/${encodeURIComponent(testData.inn)}`,\n        expect.objectContaining({\n          timeout: expect.any(Number)\n        })\n      );\n\n      expect(result.success).toBe(true);\n      expect(result.data).toEqual(mockResponses.vektor.data);\n    });\n\n    it('should properly encode search queries in URL', async () => {\n      const specialQueries = [\n        'test@domain.com',\n        '+7 912 345-67-89',\n        '1234 567890',\n        'query with spaces'\n      ];\n\n      for (const query of specialQueries) {\n        mockedAxios.get.mockResolvedValue({\n          data: { results: [], found: false },\n          status: 200\n        });\n\n        await client.search(query, 'phone');\n\n        expect(mockedAxios.get).toHaveBeenCalledWith(\n          `/api/test-vektor-token/extended_search/${encodeURIComponent(query)}`,\n          expect.any(Object)\n        );\n      }\n    });\n\n    it('should handle 404 responses gracefully', async () => {\n      mockedAxios.get.mockRejectedValue({\n        response: {\n          status: 404,\n          data: { error: 'Endpoint not found' }\n        }\n      });\n\n      const result = await client.search(testData.inn, 'inn');\n\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('not found');\n    });\n  });\n\n  describe('Cross-Client Integration', () => {\n    let clients: any[];\n\n    beforeEach(() => {\n      clients = [\n        new DyxlessClient(),\n        new ITPClient(),\n        new LeakOsintClient(),\n        new UserboxClient(),\n        new VektorClient()\n      ];\n    });\n\n    it('should handle parallel requests from all clients', async () => {\n      // Mock responses for all clients\n      mockedAxios.post.mockResolvedValue({ data: { found: false }, status: 200 });\n      mockedAxios.get.mockResolvedValue({ data: { found: false }, status: 200 });\n\n      const promises = clients.map(client => \n        client.search(testData.phone, 'phone')\n      );\n\n      const results = await Promise.all(promises);\n\n      expect(results).toHaveLength(5);\n      results.forEach(result => {\n        expect(result.success).toBe(true);\n      });\n    });\n\n    it('should handle mixed success and failure scenarios', async () => {\n      // Mock different responses for different clients\n      mockedAxios.post\n        .mockResolvedValueOnce({ data: { found: true }, status: 200 }) // Dyxless success\n        .mockRejectedValueOnce({ response: { status: 500 } }) // LeakOsint failure\n        .mockResolvedValueOnce({ data: { found: false }, status: 200 }); // ITP success\n      \n      mockedAxios.get\n        .mockRejectedValueOnce({ response: { status: 401 } }) // Userbox failure\n        .mockResolvedValueOnce({ data: { found: true }, status: 200 }); // Vektor success\n\n      const promises = clients.map(client => \n        client.search(testData.phone, 'phone')\n      );\n\n      const results = await Promise.all(promises);\n\n      expect(results).toHaveLength(5);\n      \n      // Check that some succeeded and some failed\n      const successCount = results.filter(r => r.success).length;\n      const failureCount = results.filter(r => !r.success).length;\n      \n      expect(successCount).toBeGreaterThan(0);\n      expect(failureCount).toBeGreaterThan(0);\n      expect(successCount + failureCount).toBe(5);\n    });\n\n    it('should maintain consistent interface across all clients', async () => {\n      mockedAxios.post.mockResolvedValue({ data: { found: true }, status: 200 });\n      mockedAxios.get.mockResolvedValue({ data: { found: true }, status: 200 });\n\n      for (const client of clients) {\n        const result = await client.search(testData.phone, 'phone');\n        \n        // All clients should return consistent interface\n        expect(result).toHaveProperty('success');\n        expect(typeof result.success).toBe('boolean');\n        \n        if (result.success) {\n          expect(result).toHaveProperty('data');\n        } else {\n          expect(result).toHaveProperty('error');\n          expect(typeof result.error).toBe('string');\n        }\n      }\n    });\n  });\n\n  describe('Network Error Handling Integration', () => {\n    it('should handle network connectivity issues', async () => {\n      const networkErrors = [\n        { code: 'ENOTFOUND', message: 'getaddrinfo ENOTFOUND' },\n        { code: 'ECONNREFUSED', message: 'connect ECONNREFUSED' },\n        { code: 'ETIMEDOUT', message: 'connect ETIMEDOUT' },\n        { code: 'ECONNRESET', message: 'socket hang up' }\n      ];\n\n      const client = new DyxlessClient();\n\n      for (const error of networkErrors) {\n        mockedAxios.post.mockRejectedValue(error);\n\n        const result = await client.search(testData.phone, 'phone');\n\n        expect(result.success).toBe(false);\n        expect(result.error).toBeDefined();\n        expect(typeof result.error).toBe('string');\n      }\n    });\n\n    it('should handle SSL/TLS certificate errors', async () => {\n      mockedAxios.post.mockRejectedValue({\n        code: 'CERT_UNTRUSTED',\n        message: 'certificate verify failed'\n      });\n\n      const client = new DyxlessClient();\n      const result = await client.search(testData.phone, 'phone');\n\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('certificate');\n    });\n  });\n\n  describe('Data Sanitization Integration', () => {\n    it('should not log sensitive data in error messages', async () => {\n      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();\n      \n      mockedAxios.post.mockRejectedValue({\n        response: {\n          status: 400,\n          data: { error: `Invalid phone number: ${testData.phone}` }\n        }\n      });\n\n      const client = new DyxlessClient();\n      await client.search(testData.phone, 'phone');\n\n      // Check that sensitive data is not in console logs\n      const loggedContent = consoleSpy.mock.calls.flat().join(' ');\n      expect(loggedContent).not.toContain(testData.phone);\n      \n      consoleSpy.mockRestore();\n    });\n\n    it('should sanitize response data containing PII', async () => {\n      const responseWithPII = {\n        found: true,\n        results: [{\n          field: 'phone',\n          value: testData.phone,\n          additionalInfo: `User phone: ${testData.phone}, Email: ${testData.email}`\n        }]\n      };\n\n      mockedAxios.post.mockResolvedValue({\n        data: responseWithPII,\n        status: 200\n      });\n\n      const client = new DyxlessClient();\n      const result = await client.search(testData.phone, 'phone');\n\n      expect(result.success).toBe(true);\n      // In a real implementation, you might want to sanitize the response\n      expect(result.data).toBeDefined();\n    });\n  });\n});\n\n// Cleanup after tests\nafterAll(() => {\n  jest.restoreAllMocks();\n});"